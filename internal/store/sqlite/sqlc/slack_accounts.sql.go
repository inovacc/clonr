// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: slack_accounts.sql

package sqlc

import (
	"context"
)

const clearActiveSlackAccount = `-- name: ClearActiveSlackAccount :exec
UPDATE slack_accounts SET is_default = 0
`

func (q *Queries) ClearActiveSlackAccount(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, clearActiveSlackAccount)
	return err
}

const deleteSlackAccount = `-- name: DeleteSlackAccount :exec
DELETE FROM slack_accounts WHERE name = ?
`

func (q *Queries) DeleteSlackAccount(ctx context.Context, name string) error {
	_, err := q.db.ExecContext(ctx, deleteSlackAccount, name)
	return err
}

const getActiveSlackAccount = `-- name: GetActiveSlackAccount :one
SELECT name, workspace_id, workspace_name, bot_user_id, team_id, is_default, encrypted_bot_token, token_storage, created_at, last_used_at FROM slack_accounts WHERE is_default = 1 LIMIT 1
`

func (q *Queries) GetActiveSlackAccount(ctx context.Context) (SlackAccount, error) {
	row := q.db.QueryRowContext(ctx, getActiveSlackAccount)
	var i SlackAccount
	err := row.Scan(
		&i.Name,
		&i.WorkspaceID,
		&i.WorkspaceName,
		&i.BotUserID,
		&i.TeamID,
		&i.IsDefault,
		&i.EncryptedBotToken,
		&i.TokenStorage,
		&i.CreatedAt,
		&i.LastUsedAt,
	)
	return i, err
}

const getSlackAccount = `-- name: GetSlackAccount :one
SELECT name, workspace_id, workspace_name, bot_user_id, team_id, is_default, encrypted_bot_token, token_storage, created_at, last_used_at FROM slack_accounts WHERE name = ? LIMIT 1
`

func (q *Queries) GetSlackAccount(ctx context.Context, name string) (SlackAccount, error) {
	row := q.db.QueryRowContext(ctx, getSlackAccount, name)
	var i SlackAccount
	err := row.Scan(
		&i.Name,
		&i.WorkspaceID,
		&i.WorkspaceName,
		&i.BotUserID,
		&i.TeamID,
		&i.IsDefault,
		&i.EncryptedBotToken,
		&i.TokenStorage,
		&i.CreatedAt,
		&i.LastUsedAt,
	)
	return i, err
}

const insertSlackAccount = `-- name: InsertSlackAccount :one
INSERT INTO slack_accounts (
    name, workspace_id, workspace_name, bot_user_id, team_id,
    is_default, encrypted_bot_token, token_storage, created_at, last_used_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, NULL)
RETURNING name, workspace_id, workspace_name, bot_user_id, team_id, is_default, encrypted_bot_token, token_storage, created_at, last_used_at
`

type InsertSlackAccountParams struct {
	Name              string  `json:"name"`
	WorkspaceID       *string `json:"workspace_id"`
	WorkspaceName     *string `json:"workspace_name"`
	BotUserID         *string `json:"bot_user_id"`
	TeamID            *string `json:"team_id"`
	IsDefault         *int64  `json:"is_default"`
	EncryptedBotToken []byte  `json:"encrypted_bot_token"`
	TokenStorage      *string `json:"token_storage"`
}

func (q *Queries) InsertSlackAccount(ctx context.Context, arg InsertSlackAccountParams) (SlackAccount, error) {
	row := q.db.QueryRowContext(ctx, insertSlackAccount,
		arg.Name,
		arg.WorkspaceID,
		arg.WorkspaceName,
		arg.BotUserID,
		arg.TeamID,
		arg.IsDefault,
		arg.EncryptedBotToken,
		arg.TokenStorage,
	)
	var i SlackAccount
	err := row.Scan(
		&i.Name,
		&i.WorkspaceID,
		&i.WorkspaceName,
		&i.BotUserID,
		&i.TeamID,
		&i.IsDefault,
		&i.EncryptedBotToken,
		&i.TokenStorage,
		&i.CreatedAt,
		&i.LastUsedAt,
	)
	return i, err
}

const listSlackAccounts = `-- name: ListSlackAccounts :many
SELECT name, workspace_id, workspace_name, bot_user_id, team_id, is_default, encrypted_bot_token, token_storage, created_at, last_used_at FROM slack_accounts ORDER BY name ASC
`

func (q *Queries) ListSlackAccounts(ctx context.Context) ([]SlackAccount, error) {
	rows, err := q.db.QueryContext(ctx, listSlackAccounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SlackAccount{}
	for rows.Next() {
		var i SlackAccount
		if err := rows.Scan(
			&i.Name,
			&i.WorkspaceID,
			&i.WorkspaceName,
			&i.BotUserID,
			&i.TeamID,
			&i.IsDefault,
			&i.EncryptedBotToken,
			&i.TokenStorage,
			&i.CreatedAt,
			&i.LastUsedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setActiveSlackAccount = `-- name: SetActiveSlackAccount :exec
UPDATE slack_accounts SET is_default = CASE WHEN name = ? THEN 1 ELSE 0 END
`

func (q *Queries) SetActiveSlackAccount(ctx context.Context, name string) error {
	_, err := q.db.ExecContext(ctx, setActiveSlackAccount, name)
	return err
}

const slackAccountExists = `-- name: SlackAccountExists :one
SELECT EXISTS(SELECT 1 FROM slack_accounts WHERE name = ?) AS exists_flag
`

func (q *Queries) SlackAccountExists(ctx context.Context, name string) (int64, error) {
	row := q.db.QueryRowContext(ctx, slackAccountExists, name)
	var exists_flag int64
	err := row.Scan(&exists_flag)
	return exists_flag, err
}

const updateSlackAccount = `-- name: UpdateSlackAccount :exec
UPDATE slack_accounts SET
    workspace_id = ?,
    workspace_name = ?,
    bot_user_id = ?,
    team_id = ?,
    encrypted_bot_token = ?,
    token_storage = ?,
    last_used_at = CURRENT_TIMESTAMP
WHERE name = ?
`

type UpdateSlackAccountParams struct {
	WorkspaceID       *string `json:"workspace_id"`
	WorkspaceName     *string `json:"workspace_name"`
	BotUserID         *string `json:"bot_user_id"`
	TeamID            *string `json:"team_id"`
	EncryptedBotToken []byte  `json:"encrypted_bot_token"`
	TokenStorage      *string `json:"token_storage"`
	Name              string  `json:"name"`
}

func (q *Queries) UpdateSlackAccount(ctx context.Context, arg UpdateSlackAccountParams) error {
	_, err := q.db.ExecContext(ctx, updateSlackAccount,
		arg.WorkspaceID,
		arg.WorkspaceName,
		arg.BotUserID,
		arg.TeamID,
		arg.EncryptedBotToken,
		arg.TokenStorage,
		arg.Name,
	)
	return err
}

const updateSlackAccountLastUsed = `-- name: UpdateSlackAccountLastUsed :exec
UPDATE slack_accounts SET last_used_at = CURRENT_TIMESTAMP WHERE name = ?
`

func (q *Queries) UpdateSlackAccountLastUsed(ctx context.Context, name string) error {
	_, err := q.db.ExecContext(ctx, updateSlackAccountLastUsed, name)
	return err
}
