// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: synced_data.sql

package sqlc

import (
	"context"
	"time"
)

const deletePendingRegistration = `-- name: DeletePendingRegistration :exec
DELETE FROM pending_registrations WHERE client_id = ?
`

func (q *Queries) DeletePendingRegistration(ctx context.Context, clientID string) error {
	_, err := q.db.ExecContext(ctx, deletePendingRegistration, clientID)
	return err
}

const deleteRegisteredClient = `-- name: DeleteRegisteredClient :exec
DELETE FROM registered_clients WHERE client_id = ?
`

func (q *Queries) DeleteRegisteredClient(ctx context.Context, clientID string) error {
	_, err := q.db.ExecContext(ctx, deleteRegisteredClient, clientID)
	return err
}

const deleteSyncedData = `-- name: DeleteSyncedData :exec
DELETE FROM synced_data
WHERE connection_name = ? AND data_type = ? AND name = ?
`

type DeleteSyncedDataParams struct {
	ConnectionName string `json:"connection_name"`
	DataType       string `json:"data_type"`
	Name           string `json:"name"`
}

func (q *Queries) DeleteSyncedData(ctx context.Context, arg DeleteSyncedDataParams) error {
	_, err := q.db.ExecContext(ctx, deleteSyncedData, arg.ConnectionName, arg.DataType, arg.Name)
	return err
}

const deleteSyncedDataByConnection = `-- name: DeleteSyncedDataByConnection :exec
DELETE FROM synced_data WHERE connection_name = ?
`

func (q *Queries) DeleteSyncedDataByConnection(ctx context.Context, connectionName string) error {
	_, err := q.db.ExecContext(ctx, deleteSyncedDataByConnection, connectionName)
	return err
}

const getPendingRegistration = `-- name: GetPendingRegistration :one
SELECT client_id, client_name, machine_info, state, challenge_token, challenge_at, initiated_at, completed_at FROM pending_registrations WHERE client_id = ? LIMIT 1
`

// Pending Registrations (server side)
func (q *Queries) GetPendingRegistration(ctx context.Context, clientID string) (PendingRegistration, error) {
	row := q.db.QueryRowContext(ctx, getPendingRegistration, clientID)
	var i PendingRegistration
	err := row.Scan(
		&i.ClientID,
		&i.ClientName,
		&i.MachineInfo,
		&i.State,
		&i.ChallengeToken,
		&i.ChallengeAt,
		&i.InitiatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getRegisteredClient = `-- name: GetRegisteredClient :one
SELECT client_id, client_name, machine_info, encryption_key_hash, encryption_salt, key_hint, status, sync_count, last_ip, registered_at, last_seen_at FROM registered_clients WHERE client_id = ? LIMIT 1
`

// Registered Clients (server side)
func (q *Queries) GetRegisteredClient(ctx context.Context, clientID string) (RegisteredClient, error) {
	row := q.db.QueryRowContext(ctx, getRegisteredClient, clientID)
	var i RegisteredClient
	err := row.Scan(
		&i.ClientID,
		&i.ClientName,
		&i.MachineInfo,
		&i.EncryptionKeyHash,
		&i.EncryptionSalt,
		&i.KeyHint,
		&i.Status,
		&i.SyncCount,
		&i.LastIp,
		&i.RegisteredAt,
		&i.LastSeenAt,
	)
	return i, err
}

const getSyncedData = `-- name: GetSyncedData :one
SELECT id, connection_name, instance_id, data_type, name, encrypted_data, nonce, state, checksum, synced_at, decrypted_at FROM synced_data
WHERE connection_name = ? AND data_type = ? AND name = ?
LIMIT 1
`

type GetSyncedDataParams struct {
	ConnectionName string `json:"connection_name"`
	DataType       string `json:"data_type"`
	Name           string `json:"name"`
}

// Synced Data
func (q *Queries) GetSyncedData(ctx context.Context, arg GetSyncedDataParams) (SyncedDatum, error) {
	row := q.db.QueryRowContext(ctx, getSyncedData, arg.ConnectionName, arg.DataType, arg.Name)
	var i SyncedDatum
	err := row.Scan(
		&i.ID,
		&i.ConnectionName,
		&i.InstanceID,
		&i.DataType,
		&i.Name,
		&i.EncryptedData,
		&i.Nonce,
		&i.State,
		&i.Checksum,
		&i.SyncedAt,
		&i.DecryptedAt,
	)
	return i, err
}

const insertPendingRegistration = `-- name: InsertPendingRegistration :exec
INSERT INTO pending_registrations (
    client_id, client_name, machine_info, state,
    challenge_token, challenge_at, initiated_at, completed_at
) VALUES (?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, NULL)
ON CONFLICT(client_id) DO UPDATE SET
    client_name = excluded.client_name,
    machine_info = excluded.machine_info,
    state = excluded.state,
    challenge_token = excluded.challenge_token,
    challenge_at = excluded.challenge_at
`

type InsertPendingRegistrationParams struct {
	ClientID       string    `json:"client_id"`
	ClientName     string    `json:"client_name"`
	MachineInfo    *string   `json:"machine_info"`
	State          *string   `json:"state"`
	ChallengeToken *string   `json:"challenge_token"`
	ChallengeAt    time.Time `json:"challenge_at"`
}

func (q *Queries) InsertPendingRegistration(ctx context.Context, arg InsertPendingRegistrationParams) error {
	_, err := q.db.ExecContext(ctx, insertPendingRegistration,
		arg.ClientID,
		arg.ClientName,
		arg.MachineInfo,
		arg.State,
		arg.ChallengeToken,
		arg.ChallengeAt,
	)
	return err
}

const insertRegisteredClient = `-- name: InsertRegisteredClient :exec
INSERT INTO registered_clients (
    client_id, client_name, machine_info, encryption_key_hash, encryption_salt,
    key_hint, status, sync_count, last_ip, registered_at, last_seen_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, NULL)
ON CONFLICT(client_id) DO UPDATE SET
    client_name = excluded.client_name,
    machine_info = excluded.machine_info,
    encryption_key_hash = excluded.encryption_key_hash,
    encryption_salt = excluded.encryption_salt,
    key_hint = excluded.key_hint,
    status = excluded.status
`

type InsertRegisteredClientParams struct {
	ClientID          string  `json:"client_id"`
	ClientName        string  `json:"client_name"`
	MachineInfo       *string `json:"machine_info"`
	EncryptionKeyHash []byte  `json:"encryption_key_hash"`
	EncryptionSalt    []byte  `json:"encryption_salt"`
	KeyHint           *string `json:"key_hint"`
	Status            *string `json:"status"`
	SyncCount         *int64  `json:"sync_count"`
	LastIp            *string `json:"last_ip"`
}

func (q *Queries) InsertRegisteredClient(ctx context.Context, arg InsertRegisteredClientParams) error {
	_, err := q.db.ExecContext(ctx, insertRegisteredClient,
		arg.ClientID,
		arg.ClientName,
		arg.MachineInfo,
		arg.EncryptionKeyHash,
		arg.EncryptionSalt,
		arg.KeyHint,
		arg.Status,
		arg.SyncCount,
		arg.LastIp,
	)
	return err
}

const insertSyncedData = `-- name: InsertSyncedData :one
INSERT INTO synced_data (
    id, connection_name, instance_id, data_type, name,
    encrypted_data, nonce, state, checksum, synced_at, decrypted_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, NULL)
RETURNING id, connection_name, instance_id, data_type, name, encrypted_data, nonce, state, checksum, synced_at, decrypted_at
`

type InsertSyncedDataParams struct {
	ID             string  `json:"id"`
	ConnectionName string  `json:"connection_name"`
	InstanceID     *string `json:"instance_id"`
	DataType       string  `json:"data_type"`
	Name           string  `json:"name"`
	EncryptedData  []byte  `json:"encrypted_data"`
	Nonce          []byte  `json:"nonce"`
	State          *string `json:"state"`
	Checksum       *string `json:"checksum"`
}

func (q *Queries) InsertSyncedData(ctx context.Context, arg InsertSyncedDataParams) (SyncedDatum, error) {
	row := q.db.QueryRowContext(ctx, insertSyncedData,
		arg.ID,
		arg.ConnectionName,
		arg.InstanceID,
		arg.DataType,
		arg.Name,
		arg.EncryptedData,
		arg.Nonce,
		arg.State,
		arg.Checksum,
	)
	var i SyncedDatum
	err := row.Scan(
		&i.ID,
		&i.ConnectionName,
		&i.InstanceID,
		&i.DataType,
		&i.Name,
		&i.EncryptedData,
		&i.Nonce,
		&i.State,
		&i.Checksum,
		&i.SyncedAt,
		&i.DecryptedAt,
	)
	return i, err
}

const listPendingRegistrations = `-- name: ListPendingRegistrations :many
SELECT client_id, client_name, machine_info, state, challenge_token, challenge_at, initiated_at, completed_at FROM pending_registrations ORDER BY initiated_at DESC
`

func (q *Queries) ListPendingRegistrations(ctx context.Context) ([]PendingRegistration, error) {
	rows, err := q.db.QueryContext(ctx, listPendingRegistrations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PendingRegistration{}
	for rows.Next() {
		var i PendingRegistration
		if err := rows.Scan(
			&i.ClientID,
			&i.ClientName,
			&i.MachineInfo,
			&i.State,
			&i.ChallengeToken,
			&i.ChallengeAt,
			&i.InitiatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRegisteredClients = `-- name: ListRegisteredClients :many
SELECT client_id, client_name, machine_info, encryption_key_hash, encryption_salt, key_hint, status, sync_count, last_ip, registered_at, last_seen_at FROM registered_clients ORDER BY registered_at DESC
`

func (q *Queries) ListRegisteredClients(ctx context.Context) ([]RegisteredClient, error) {
	rows, err := q.db.QueryContext(ctx, listRegisteredClients)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RegisteredClient{}
	for rows.Next() {
		var i RegisteredClient
		if err := rows.Scan(
			&i.ClientID,
			&i.ClientName,
			&i.MachineInfo,
			&i.EncryptionKeyHash,
			&i.EncryptionSalt,
			&i.KeyHint,
			&i.Status,
			&i.SyncCount,
			&i.LastIp,
			&i.RegisteredAt,
			&i.LastSeenAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRegisteredClientsByStatus = `-- name: ListRegisteredClientsByStatus :many
SELECT client_id, client_name, machine_info, encryption_key_hash, encryption_salt, key_hint, status, sync_count, last_ip, registered_at, last_seen_at FROM registered_clients WHERE status = ? ORDER BY registered_at DESC
`

func (q *Queries) ListRegisteredClientsByStatus(ctx context.Context, status *string) ([]RegisteredClient, error) {
	rows, err := q.db.QueryContext(ctx, listRegisteredClientsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RegisteredClient{}
	for rows.Next() {
		var i RegisteredClient
		if err := rows.Scan(
			&i.ClientID,
			&i.ClientName,
			&i.MachineInfo,
			&i.EncryptionKeyHash,
			&i.EncryptionSalt,
			&i.KeyHint,
			&i.Status,
			&i.SyncCount,
			&i.LastIp,
			&i.RegisteredAt,
			&i.LastSeenAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSyncedDataByConnection = `-- name: ListSyncedDataByConnection :many
SELECT id, connection_name, instance_id, data_type, name, encrypted_data, nonce, state, checksum, synced_at, decrypted_at FROM synced_data
WHERE connection_name = ?
ORDER BY synced_at DESC
`

func (q *Queries) ListSyncedDataByConnection(ctx context.Context, connectionName string) ([]SyncedDatum, error) {
	rows, err := q.db.QueryContext(ctx, listSyncedDataByConnection, connectionName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SyncedDatum{}
	for rows.Next() {
		var i SyncedDatum
		if err := rows.Scan(
			&i.ID,
			&i.ConnectionName,
			&i.InstanceID,
			&i.DataType,
			&i.Name,
			&i.EncryptedData,
			&i.Nonce,
			&i.State,
			&i.Checksum,
			&i.SyncedAt,
			&i.DecryptedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSyncedDataByConnectionAndType = `-- name: ListSyncedDataByConnectionAndType :many
SELECT id, connection_name, instance_id, data_type, name, encrypted_data, nonce, state, checksum, synced_at, decrypted_at FROM synced_data
WHERE connection_name = ? AND data_type = ?
ORDER BY synced_at DESC
`

type ListSyncedDataByConnectionAndTypeParams struct {
	ConnectionName string `json:"connection_name"`
	DataType       string `json:"data_type"`
}

func (q *Queries) ListSyncedDataByConnectionAndType(ctx context.Context, arg ListSyncedDataByConnectionAndTypeParams) ([]SyncedDatum, error) {
	rows, err := q.db.QueryContext(ctx, listSyncedDataByConnectionAndType, arg.ConnectionName, arg.DataType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SyncedDatum{}
	for rows.Next() {
		var i SyncedDatum
		if err := rows.Scan(
			&i.ID,
			&i.ConnectionName,
			&i.InstanceID,
			&i.DataType,
			&i.Name,
			&i.EncryptedData,
			&i.Nonce,
			&i.State,
			&i.Checksum,
			&i.SyncedAt,
			&i.DecryptedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSyncedDataByState = `-- name: ListSyncedDataByState :many
SELECT id, connection_name, instance_id, data_type, name, encrypted_data, nonce, state, checksum, synced_at, decrypted_at FROM synced_data
WHERE state = ?
ORDER BY synced_at DESC
`

func (q *Queries) ListSyncedDataByState(ctx context.Context, state *string) ([]SyncedDatum, error) {
	rows, err := q.db.QueryContext(ctx, listSyncedDataByState, state)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SyncedDatum{}
	for rows.Next() {
		var i SyncedDatum
		if err := rows.Scan(
			&i.ID,
			&i.ConnectionName,
			&i.InstanceID,
			&i.DataType,
			&i.Name,
			&i.EncryptedData,
			&i.Nonce,
			&i.State,
			&i.Checksum,
			&i.SyncedAt,
			&i.DecryptedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePendingRegistrationState = `-- name: UpdatePendingRegistrationState :exec
UPDATE pending_registrations SET
    state = ?1,
    completed_at = CASE WHEN @state IN ('completed', 'rejected') THEN CURRENT_TIMESTAMP ELSE completed_at END
WHERE client_id = ?2
`

type UpdatePendingRegistrationStateParams struct {
	State    *string `json:"state"`
	ClientID string  `json:"client_id"`
}

func (q *Queries) UpdatePendingRegistrationState(ctx context.Context, arg UpdatePendingRegistrationStateParams) error {
	_, err := q.db.ExecContext(ctx, updatePendingRegistrationState, arg.State, arg.ClientID)
	return err
}

const updateRegisteredClientLastSeen = `-- name: UpdateRegisteredClientLastSeen :exec
UPDATE registered_clients SET
    last_seen_at = CURRENT_TIMESTAMP,
    last_ip = ?,
    sync_count = sync_count + 1
WHERE client_id = ?
`

type UpdateRegisteredClientLastSeenParams struct {
	LastIp   *string `json:"last_ip"`
	ClientID string  `json:"client_id"`
}

func (q *Queries) UpdateRegisteredClientLastSeen(ctx context.Context, arg UpdateRegisteredClientLastSeenParams) error {
	_, err := q.db.ExecContext(ctx, updateRegisteredClientLastSeen, arg.LastIp, arg.ClientID)
	return err
}

const updateRegisteredClientStatus = `-- name: UpdateRegisteredClientStatus :exec
UPDATE registered_clients SET status = ? WHERE client_id = ?
`

type UpdateRegisteredClientStatusParams struct {
	Status   *string `json:"status"`
	ClientID string  `json:"client_id"`
}

func (q *Queries) UpdateRegisteredClientStatus(ctx context.Context, arg UpdateRegisteredClientStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateRegisteredClientStatus, arg.Status, arg.ClientID)
	return err
}

const updateSyncedDataState = `-- name: UpdateSyncedDataState :exec
UPDATE synced_data SET
    state = ?1,
    decrypted_at = CASE WHEN ?1 = 'decrypted' THEN CURRENT_TIMESTAMP ELSE decrypted_at END
WHERE connection_name = ?2 AND data_type = ?3 AND name = ?4
`

type UpdateSyncedDataStateParams struct {
	State          *string `json:"state"`
	ConnectionName string  `json:"connection_name"`
	DataType       string  `json:"data_type"`
	Name           string  `json:"name"`
}

func (q *Queries) UpdateSyncedDataState(ctx context.Context, arg UpdateSyncedDataStateParams) error {
	_, err := q.db.ExecContext(ctx, updateSyncedDataState,
		arg.State,
		arg.ConnectionName,
		arg.DataType,
		arg.Name,
	)
	return err
}

const upsertSyncedData = `-- name: UpsertSyncedData :exec
INSERT INTO synced_data (
    id, connection_name, instance_id, data_type, name,
    encrypted_data, nonce, state, checksum, synced_at, decrypted_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, NULL)
ON CONFLICT(connection_name, data_type, name) DO UPDATE SET
    instance_id = excluded.instance_id,
    encrypted_data = excluded.encrypted_data,
    nonce = excluded.nonce,
    state = excluded.state,
    checksum = excluded.checksum,
    synced_at = CURRENT_TIMESTAMP
`

type UpsertSyncedDataParams struct {
	ID             string  `json:"id"`
	ConnectionName string  `json:"connection_name"`
	InstanceID     *string `json:"instance_id"`
	DataType       string  `json:"data_type"`
	Name           string  `json:"name"`
	EncryptedData  []byte  `json:"encrypted_data"`
	Nonce          []byte  `json:"nonce"`
	State          *string `json:"state"`
	Checksum       *string `json:"checksum"`
}

func (q *Queries) UpsertSyncedData(ctx context.Context, arg UpsertSyncedDataParams) error {
	_, err := q.db.ExecContext(ctx, upsertSyncedData,
		arg.ID,
		arg.ConnectionName,
		arg.InstanceID,
		arg.DataType,
		arg.Name,
		arg.EncryptedData,
		arg.Nonce,
		arg.State,
		arg.Checksum,
	)
	return err
}
