// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: repositories.sql

package sqlc

import (
	"context"
)

const deleteRepoByPath = `-- name: DeleteRepoByPath :exec
DELETE FROM repositories WHERE path = ?
`

func (q *Queries) DeleteRepoByPath(ctx context.Context, path string) error {
	_, err := q.db.ExecContext(ctx, deleteRepoByPath, path)
	return err
}

const deleteRepoByURL = `-- name: DeleteRepoByURL :exec
DELETE FROM repositories WHERE url = ?
`

func (q *Queries) DeleteRepoByURL(ctx context.Context, url string) error {
	_, err := q.db.ExecContext(ctx, deleteRepoByURL, url)
	return err
}

const getAllRepos = `-- name: GetAllRepos :many
SELECT id, uid, url, path, workspace, favorite, cloned_at, updated_at, last_checked FROM repositories ORDER BY updated_at DESC
`

func (q *Queries) GetAllRepos(ctx context.Context) ([]Repository, error) {
	rows, err := q.db.QueryContext(ctx, getAllRepos)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Repository{}
	for rows.Next() {
		var i Repository
		if err := rows.Scan(
			&i.ID,
			&i.Uid,
			&i.Url,
			&i.Path,
			&i.Workspace,
			&i.Favorite,
			&i.ClonedAt,
			&i.UpdatedAt,
			&i.LastChecked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRepoByPath = `-- name: GetRepoByPath :one
SELECT id, uid, url, path, workspace, favorite, cloned_at, updated_at, last_checked FROM repositories WHERE path = ? LIMIT 1
`

func (q *Queries) GetRepoByPath(ctx context.Context, path string) (Repository, error) {
	row := q.db.QueryRowContext(ctx, getRepoByPath, path)
	var i Repository
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.Url,
		&i.Path,
		&i.Workspace,
		&i.Favorite,
		&i.ClonedAt,
		&i.UpdatedAt,
		&i.LastChecked,
	)
	return i, err
}

const getRepoByURL = `-- name: GetRepoByURL :one
SELECT id, uid, url, path, workspace, favorite, cloned_at, updated_at, last_checked FROM repositories WHERE url = ? LIMIT 1
`

func (q *Queries) GetRepoByURL(ctx context.Context, url string) (Repository, error) {
	row := q.db.QueryRowContext(ctx, getRepoByURL, url)
	var i Repository
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.Url,
		&i.Path,
		&i.Workspace,
		&i.Favorite,
		&i.ClonedAt,
		&i.UpdatedAt,
		&i.LastChecked,
	)
	return i, err
}

const getReposByWorkspace = `-- name: GetReposByWorkspace :many
SELECT id, uid, url, path, workspace, favorite, cloned_at, updated_at, last_checked FROM repositories WHERE workspace = ? ORDER BY updated_at DESC
`

func (q *Queries) GetReposByWorkspace(ctx context.Context, workspace *string) ([]Repository, error) {
	rows, err := q.db.QueryContext(ctx, getReposByWorkspace, workspace)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Repository{}
	for rows.Next() {
		var i Repository
		if err := rows.Scan(
			&i.ID,
			&i.Uid,
			&i.Url,
			&i.Path,
			&i.Workspace,
			&i.Favorite,
			&i.ClonedAt,
			&i.UpdatedAt,
			&i.LastChecked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReposByWorkspaceAndFavorites = `-- name: GetReposByWorkspaceAndFavorites :many
SELECT id, uid, url, path, workspace, favorite, cloned_at, updated_at, last_checked FROM repositories
WHERE (workspace = ? OR ? = '')
  AND (favorite = 1 OR ? = 0)
ORDER BY updated_at DESC
`

type GetReposByWorkspaceAndFavoritesParams struct {
	Workspace *string     `json:"workspace"`
	Column2   interface{} `json:"column_2"`
	Column3   interface{} `json:"column_3"`
}

func (q *Queries) GetReposByWorkspaceAndFavorites(ctx context.Context, arg GetReposByWorkspaceAndFavoritesParams) ([]Repository, error) {
	rows, err := q.db.QueryContext(ctx, getReposByWorkspaceAndFavorites, arg.Workspace, arg.Column2, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Repository{}
	for rows.Next() {
		var i Repository
		if err := rows.Scan(
			&i.ID,
			&i.Uid,
			&i.Url,
			&i.Path,
			&i.Workspace,
			&i.Favorite,
			&i.ClonedAt,
			&i.UpdatedAt,
			&i.LastChecked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertRepo = `-- name: InsertRepo :one
INSERT INTO repositories (uid, url, path, workspace, favorite, cloned_at, updated_at)
VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
RETURNING id, uid, url, path, workspace, favorite, cloned_at, updated_at, last_checked
`

type InsertRepoParams struct {
	Uid       string  `json:"uid"`
	Url       string  `json:"url"`
	Path      string  `json:"path"`
	Workspace *string `json:"workspace"`
	Favorite  *int64  `json:"favorite"`
}

func (q *Queries) InsertRepo(ctx context.Context, arg InsertRepoParams) (Repository, error) {
	row := q.db.QueryRowContext(ctx, insertRepo,
		arg.Uid,
		arg.Url,
		arg.Path,
		arg.Workspace,
		arg.Favorite,
	)
	var i Repository
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.Url,
		&i.Path,
		&i.Workspace,
		&i.Favorite,
		&i.ClonedAt,
		&i.UpdatedAt,
		&i.LastChecked,
	)
	return i, err
}

const repoExistsByPath = `-- name: RepoExistsByPath :one
SELECT EXISTS(SELECT 1 FROM repositories WHERE path = ?) AS exists_flag
`

func (q *Queries) RepoExistsByPath(ctx context.Context, path string) (int64, error) {
	row := q.db.QueryRowContext(ctx, repoExistsByPath, path)
	var exists_flag int64
	err := row.Scan(&exists_flag)
	return exists_flag, err
}

const repoExistsByURL = `-- name: RepoExistsByURL :one
SELECT EXISTS(SELECT 1 FROM repositories WHERE url = ?) AS exists_flag
`

func (q *Queries) RepoExistsByURL(ctx context.Context, url string) (int64, error) {
	row := q.db.QueryRowContext(ctx, repoExistsByURL, url)
	var exists_flag int64
	err := row.Scan(&exists_flag)
	return exists_flag, err
}

const updateRepoFavorite = `-- name: UpdateRepoFavorite :exec
UPDATE repositories SET favorite = ?, updated_at = CURRENT_TIMESTAMP WHERE url = ?
`

type UpdateRepoFavoriteParams struct {
	Favorite *int64 `json:"favorite"`
	Url      string `json:"url"`
}

func (q *Queries) UpdateRepoFavorite(ctx context.Context, arg UpdateRepoFavoriteParams) error {
	_, err := q.db.ExecContext(ctx, updateRepoFavorite, arg.Favorite, arg.Url)
	return err
}

const updateRepoLastChecked = `-- name: UpdateRepoLastChecked :exec
UPDATE repositories SET last_checked = CURRENT_TIMESTAMP WHERE url = ?
`

func (q *Queries) UpdateRepoLastChecked(ctx context.Context, url string) error {
	_, err := q.db.ExecContext(ctx, updateRepoLastChecked, url)
	return err
}

const updateRepoTimestamp = `-- name: UpdateRepoTimestamp :exec
UPDATE repositories SET updated_at = CURRENT_TIMESTAMP WHERE url = ?
`

func (q *Queries) UpdateRepoTimestamp(ctx context.Context, url string) error {
	_, err := q.db.ExecContext(ctx, updateRepoTimestamp, url)
	return err
}

const updateRepoWorkspace = `-- name: UpdateRepoWorkspace :exec
UPDATE repositories SET workspace = ?, updated_at = CURRENT_TIMESTAMP WHERE url = ?
`

type UpdateRepoWorkspaceParams struct {
	Workspace *string `json:"workspace"`
	Url       string  `json:"url"`
}

func (q *Queries) UpdateRepoWorkspace(ctx context.Context, arg UpdateRepoWorkspaceParams) error {
	_, err := q.db.ExecContext(ctx, updateRepoWorkspace, arg.Workspace, arg.Url)
	return err
}
